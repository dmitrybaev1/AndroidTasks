/****** CROSSAPI.H ************* Kruzhkov A.E.   ****** 15/07/13 ***
******* CROSSAPI.H ************* Belenkov O.V.   ****** 06/05/14 ***
*                                                                  *
*              Copyright (c) PANORAMA Group 1991-2014              *
*                      All Rights Reserved                         *
*                                                                  *
********************************************************************
*                                                                  *
*                БИБЛИОТЕКА ГЕОМЕТРИЧЕСКИХ ФУНКЦИЙ                 *
*                      И ОВЕРЛЕЙНЫХ ОПЕРАЦИЙ                       *
*            (библиотека gisacces.dll или mapacces.dll)            *
*                                                                  *
*  Функции поиска точек пересечения отрезков:                      *
*                                                                  *
*    ovlGetCrossPoint           - Определение точек пересечения    *
*                                 отрезков                         *
*    ovlGetCrossPointRealCut    - Определение точек пересечения    *
*                                 отрезков ненулевой длины         *
*    ovlCrossTestFrame          - Тест пересечения отрезка         *
*                                 с прямоугольной рамкой           *
*    ovlDistance                - Вычисление расстояния между      *
*                                 точкой и прямой                  *
*    ovlDistance2               - Вычисление квадрата расстояния   *
*                                 между точкой и прямой            *
*    ovlSeekNearPointOnLine     - Поиск точки на линии, ближайшей  *
*                                 к заданной                       *
*                                                                  *
*  Функции запроса положения точки                                 *
*                                                                  *
*    ovlGetLocationPoint        - Определение расположения точки   *
*                                 относительно замкнутого объекта  *
*                                                                  *
*  Функции пересечения объектов:                                   *
*                                                                  *
*    ovlCreate            - Создать объект оверлейных операций     *
*    ovlFree              - Освободить объект оверлейных операций  *
*                                                                  *
*    ovlSetTemplet        - Установить шаблон для оверлейных       *
*                           операций                               *
*    ovlSetObjectCross    - Установить обрабатываемый объект       *
*                           и метод обработки                      *
*    ovlGetNextObject     - Запросить очередную часть разрезаемого *
*                           объекта                                *
*                                                                  *
*    ovlIsEditTemplet     - Запросить признак изменения метрики    *
*                           шаблона                                *
*    ovlIsEditObject      - Запросить признак изменения метрики    *
*                           объекта                                *
*    ovlGetAdjustTemplet  - Запросить метрику шаблона,             *
*                           согласованную метрикой объекта         *
*    ovlGetAdjustObject   - Запросить метрику объекта,             *
*                           согласованную метрикой шаблона         *
*    ovlGetCheckObject    - Запросить метрику проверенного объекта *
*                           с удалением двойных точек              *
*    ovlGetCrossPoints    - Запросить все точки пересечения        *
*                           шаблона и объекта                      *
*                                                                  *
*  Функции запроса описания ошибок                                 *
*                                                                  *
*    ovlCreateCheckObject - Создать объект оверлейных операций     *
*                           для выполения контроля метрики объекта *
*    ovlGetErrorCode      - Запросить код ошибки                   *
*    ovlGetError          - Запросить описание ошибки              *
*    ovlGetErrorPointX    - Запросить координаты точки,            *
*    ovlGetErrorPointY      содержащей ошибку                      *
*                                                                  *
*    ovlGetErrorCount     - Запросить число ошибок                 *
*                                                                  *
*    ovlGetErrorCodeN     - Запросить код ошибки по номеру         *
*    ovlGetErrorN         - Запросить описание ошибки по номеру    *
*    ovlGetErrorPointXN   - Запросить координаты точки,            *
*    ovlGetErrorPointYN     содержащей ошибку по номеру            *
*                                                                  *
*******************************************************************/

#ifndef CROSSAPI_H
#define CROSSAPI_H

#ifndef MAPTYPE_H
  #include "maptype.h"
#endif

// Идентификатор объекта оверлейных операций
#define HOVL  void *

// CROSS-коды, возвращаемые функцией ovlGetCrossPoint

#define CROSS_0                0  // Пересечений нет
#define CROSS_1                1  // 1 ТП (одна точка пересечения/вхождения)
#define CROSS_2                2  // 2 ТП (две точки пересечения/вхождения)
#define CROSS_A1A2_EQUAL       4  // Точки отрезка A равны (отрезок нулевой длины)
#define CROSS_B1B2_EQUAL       8  // Точки отрезка B равны (отрезок нулевой длины)
#define CROSS_A1B1_EQUAL      16  // Точки A1 и B1 равны
#define CROSS_A2B2_EQUAL      32  // Точки A2 и B2 равны
#define CROSS_A1B2_EQUAL      64  // Точки A1 и B2 равны
#define CROSS_A2B1_EQUAL     128  // Точки A2 и B1 равны

// Производные CROSS-коды, возвращаемые функцией ovlGetCrossPoint

#define CROSS_A1A2_EQUAL_1     5  // Точки отрезка A равны + 1 ТП (1+4)
#define CROSS_B1B2_EQUAL_1     9  // Точки отрезка B равны + 1 ТП (1+8)

#define CROSS_AB_NULL         12  // Oтрезки A и B нулевой длины (4+8)

#define CROSS_A1B1_EQUAL_1    17  // Точки A1 и B1 равны + 1 ТП (1+16)
#define CROSS_A2B2_EQUAL_1    33  // Точки A2 и B2 равны + 1 ТП (1+32)
#define CROSS_A1B2_EQUAL_1    65  // Точки A1 и B2 равны + 1 ТП (1+64)
#define CROSS_A2B1_EQUAL_1   129  // Точки A2 и B1 равны + 1 ТП (1+128)

#define CROSS_A1B1_EQUAL_2    18  // Точки A1 и B1 равны + 2 ТП (2+16)
#define CROSS_A2B2_EQUAL_2    34  // Точки A2 и B2 равны + 2 ТП (2+32)
#define CROSS_A1B2_EQUAL_2    66  // Точки A1 и B2 равны + 2 ТП (2+64)
#define CROSS_A2B1_EQUAL_2   130  // Точки A2 и B1 равны + 2 ТП (2+128)

#define CROSS_A1A2B1_EQUAL_1 149  // Точки A1,A2,B1 равны + 1 ТП (1+4+16+128)
#define CROSS_A1A2B2_EQUAL_1 101  // Точки A1,A2,B2 равны + 1 ТП (1+4+32+64)
#define CROSS_B1B2A1_EQUAL_1  89  // Точки B1,B2,A1 равны + 1 ТП (1+8+16+64)
#define CROSS_B1B2A2_EQUAL_1 169  // Точки B1,B2,A2 равны + 1 ТП (1+8+32+128)

#define CROSS_AB_EQUAL_2      50  // Отрезки совпадают + 2 ТП (2+16+32)
                                  // (в прямом направлении)

#define CROSS_BA_EQUAL_2     194  // Отрезки совпадают + 2 ТП (2+64+128)
                                  // (в обратном направлении)

#define CROSS_ALL_EQUAL_1    253  // Все точки равны + 1 ТП (1+4+8+16+32+64+128)

#define CROSS_EQUAL_1        240  // Флаг определения наличия общей точки (16+32+64+128)

// Тестовые CROSS-коды (используются после вызова ovlGetCrossPoint)

#define CROSS_GETCOUNT         3  // Для определения числа точек пересечения


// Запросить число точек пересечения
#define CROSS_GetCount(code)      ((code) & 3)

// Проверить наличие общих точек
#define CROSS_IsEqualPoint(code) (((code) & CROSS_EQUAL_1) != 0)


// Флаги формирования высоты в точках трехмерной метрики
// (используются в ovlSetObjectCross)

#define FLAG3D_NONE     0 // Результат не содержит трехмерной метрики
#define FLAG3D_TEMPLET  2 // Третья координата выбирается из контура
                          // шаблона
#define FLAG3D_MATRIX   8 // Третья координата выбирается из карты
                          // (по наиболее точной открытой матрице высот)
#define FLAG3D_LINE    32 // Третья координата вычисляется по крайним
                          // точкам участка (методом линейной интерполяции)
#define FLAG3D_ALL     42 // Совместное использование всех флагов
                          // FLAG3D_TEMPLET|FLAG3D_MATRIX|FLAG3D_LINE

// Флаги типа результирующих контуров - флаги метода обработки
// (используются в ovlSetObjectCross)
#define METHOD_LINE     0 // Замкнутые и незамкнутые контура линейных объектов
#define METHOD_SQUARE   1 // Замкнутые контура (части object) площадных объектов
#define METHOD_FAST    16 // Быстрый способ обработки - используется только
                          // для объектов, которые не содержат самопересечений !!!

// Флаги размещения результирующих контуров (используются в ovlSetObjectCross)

#define ANYOBJECT           0x000 // Поиск всех контуров
#define ANYOBJECT2          0x360 // Поиск всех контуров, включая отрезки
                                  // контура равные отрезкам шаблона

#define OBJECTINSIDE        0x020 // Поиск контуров внутри шаблона
#define OBJECTINSIDE2       0x120 // Поиск контуров внутри шаблона, включая
                                  // отрезки контура равные отрезкам шаблона

#define OBJECTOUTSIDE       0x040 // Поиск контуров вне шаблона
#define OBJECTOUTSIDE2      0x240 // Поиск контуров вне шаблона, включая
                                  // отрезки контура равные отрезкам шаблона

#define OBJECTOVERLAP       0x100 // Поиск совпадающих участков контуров  // 15/07/13

// Коды ошибок пересечений объектов, возвращаемые функцией ovlGetErrorCode

#define OVL_ERR_NONE                      0 // "Ошибок нет",
#define OVL_ERR_UNKNOWN                   1 // "Неизвестная ошибка",
#define OVL_ERR_PARAM                     2 // "Ошибка входных параметров",
#define OVL_ERR_LOCAL                     3 // "Ошибка локализации объекта",
#define OVL_ERR_STRUCT                    4 // "Ошибка структуры объекта",
#define OVL_ERR_LESSCOUNT                 5 // "Число точек контура объекта меньше допустимого",
#define OVL_ERR_LESSCOUNT2                6 // "Число несовпадающих точек контура объекта меньше допустимого",
#define OVL_ERR_OVERCOUNT                 7 // "Общее число точек объекта больше допустимого",
#define OVL_ERR_UNLOCKED                  8 // "Контур площадного объекта незамкнут",
#define OVL_ERR_METHOD                    9 // "Контур объекта незамкнут. Ошибка заданного типа обработки",
#define OVL_ERR_MEMORY                   10 // "Ошибка при выделении памяти",
#define OVL_ERR_OVERCROSS                11 // "Число пересечений больше допустимого (буфер мал)",
#define OVL_ERR_ADDSUBJECT               12 // "Ошибка добавления подобъекта",
#define OVL_ERR_ADDPOINT                 13 // "Ошибка добавления точки",
#define OVL_ERR_DELPOINT                 14 // "Ошибка удаления точки",
#define OVL_ERR_SELFCROSSING             15 // "Обнаружено самопересечение контура объекта",
#define OVL_ERR_SELFCROSSING2            16 // "Обнаружено пересечение контуров объекта",
#define OVL_ERR_NOCROSS_OBJECTINSIDE     17 // "Пересечений нет. Объект находится внутри шаблона",
#define OVL_ERR_NOCROSS_OBJECTOUTSIDE    18 // "Пересечений нет. Объект находится вне шаблона",
#define OVL_ERR_TEMPLETOWNED             19 // "Контур объекта принадлежит контуру шаблона",
#define OVL_ERR_NOCROSS                  20 // "Ошибка обработки. Пересечений нет",
#define OVL_ERR_SUBJECT                  21 // "Входные параметры содержат ошибочный номер подобъекта шаблона",
#define OVL_ERR_SQUARE_LESSCOUNT         22 // "Площадной метод обработки. Число неравных точек контура шаблона менее 4",
#define OVL_ERR_SQUARE_UNLOCKEDTEMPLET   23 // "Площадной метод обработки. Контур шаблона незамкнут",
#define OVL_ERR_SQUARE_UNLOCKEDOBJECT    24 // "Площадной метод обработки. Контур объекта или подобъекта незамкнут",
#define OVL_ERR_INSIDE_LESSCOUNT         25 // "Поиск внутри области. Число неравных точек контура шаблона менее 4",
#define OVL_ERR_INSIDE_UNLOCKEDTEMPLET   26 // "Поиск внутри области. Контур шаблона незамкнут",
#define OVL_ERR_OUTSIDE_LESSCOUNT        27 // "Поиск вне области. Число неравных точек контура шаблона менее 4",
#define OVL_ERR_OUTSIDE_UNLOCKEDTEMPLET  28 // "Поиск вне области. Контур шаблона незамкнут",
#define OVL_ERR_GETSIDE_LESSCOUNT        29 // "Определение положения. Число неравных точек контура шаблона менее 4",
#define OVL_ERR_GETSIDE_UNLOCKEDTEMPLET  30 // "Определение положения. Контур шаблона незамкнут",
#define OVL_ERR_SUBJECTNUMBER            31 // "Запрос контура шаблона. Задан ошибочный номер подобъекта",
#define OVL_ERR_NOTEMPLET                32 // "Шаблон не установлен. Неправильный порядок вызова функций",
#define OVL_ERR_NOTEMPLET2               33 // "Шаблон не установлен. При проверке шаблона обнаружена ошибка",
#define OVL_ERR_NOOBJECT                 34 // "Обрабатываемый объект не установлен. Неправильный порядок вызова функций",
#define OVL_ERR_NOOBJECT2                35 // "Обрабатываемый объект не установлен. При проверке объекта обнаружена ошибка",
#define OVL_ERR_SELFCROSSING_OFF         36 // "Ошибка обработки. Отключена проверка на самопересечение",
#define OVL_ERR_OVERCROSS_TEMPLET        37 // "Ошибка обработки. Превышено максимальное число точек шаблона",
#define OVL_ERR_OVERCROSS_OBJECT         38 // "Ошибка обработки. Превышено максимальное число точек объекта",
#define OVL_ERR_OVERCROSS_RESULT         39 // "Ошибка обработки. Превышено максимальное число точек формируемого объекта",
#define OVL_ERR_EXCEEDS_MAXIMUM          40 // "Число ошибок превышает максимальное",
#define OVL_ERR_SELFCROSSING_OVERLAY     41 // "Обнаружены совпадающие отрезки контура объекта",
#define OVL_ERR_SELFCROSSING_OVERLAY2    42 // "Обнаружены совпадающие отрезки контуров объекта",
#define OVL_ERR_SELFCROSSING_ADJACENT    43 // "Обнаружены примыкающие отрезки контура объекта",
#define OVL_ERR_SELFCROSSING_ADJACENT2   44 // "Обнаружены примыкающие отрезки контуров объекта",
#define OVL_ERR_CHECKING_NEARPOINT       45 // "Точки контура слишком близки",
#define OVL_ERR_CHECKING_NEARPOINT2      46 // "Точки контуров слишком близки",
#define OVL_ERR_CHECKING_PEAK            47 // "Выброс в точке контура",
#define OVL_ERR_CHECKING_DOUBLEPOINT     48 // "Обнаружены двойные точки",
#define OVL_ERR_CHECKING_DOUBLEPOINT2    49 // "Обнаружены двойные точки в допуске",
#define OVL_ERR_CHECKING_OBJECTINSIDE    50 // "Площадной объект внутри подобъекта",
#define OVL_ERR_CHECKING_SUBJECTINSIDE   51 // "Подобъект площадного объекта внутри подобъекта",
#define OVL_ERR_CHECKING_SUBJECTOUTSIDE  52 // "Подобъект вне площадного объекта",
#define OVL_ERR_END                      52 // Последний код штатных ошибок

extern "C"
{
// Найти точку пересечения двух отрезков
//   a1, a2    - точки первого отрезка (A)
//   b1, b2    - точки второго отрезка (B)
//   cp1       - первая точка пересечения
//   cp2       - вторая точка пересечения
//   precision - точность, используемая для проверки равенства точек
//               (рекомендуется DOUBLENULL)
//   force     - флаг выполнения дополнительного поиска
//               (если равно 1, то учесть наличие отрезков нулевой длины)
// Возвращает CROSS-коды (code: CROSS_0, CROSS_1, CROSS_2 и др.).
// Число пересечений = (code & CROSS_GETCOUNT) = 0,1,2
// При ошибке параметров возвращает 0


_MAPIMP long int _MAPAPI ovlGetCrossPoint(DOUBLEPOINT* a1, DOUBLEPOINT* a2,
                              DOUBLEPOINT* b1, DOUBLEPOINT* b2,
                              DOUBLEPOINT* cp1, DOUBLEPOINT *cp2,
                              double precision, long int force);


// Найти точку пересечения двух отрезков ненулевой длины
// (вызывать только если отсутствует равенство точек a1=a2 и b1=b2)
//   crossCode - код пересечения
//   a1, a2    - точки первого отрезка (A)
//   b1, b2    - точки второго отрезка (B)
//   cp1       - первая точка пересечения
//   cp2       - вторая точка пересечения
//   precision - точность, используемая для проверки равенства точек
//               (рекомендуется DOUBLENULL)
//   force     - флаг выполнения дополнительного поиска
//               (если равно 1, то учесть наличие отрезков нулевой длины)
// Возвращает CROSS-коды (code: CROSS_0, CROSS_1, CROSS_2 и др.).
// Число пересечений = (code & CROSS_GETCOUNT) = 0,1,2
// При ошибке параметров возвращает 0

_MAPIMP long int _MAPAPI ovlGetCrossPointRealCut(long int crossCode,
                              DOUBLEPOINT* a1, DOUBLEPOINT* a2,
                              DOUBLEPOINT* b1, DOUBLEPOINT* b2,
                              DOUBLEPOINT* cp1, DOUBLEPOINT *cp2);


// Тест пересечения отрезка p1p2 с прямоугольной рамкой dframe
// (позднее можно оптимизировать: при пересечении габаритов и
//  если все точки рамки справа или все точки слева относительно
//  линии, то пересечений нет)
// При ошибке параметров возвращает 0

_MAPIMP long int _MAPAPI ovlCrossTestFrame(DOUBLEPOINT* p1, DOUBLEPOINT* p2,
                              DFRAME* dframe, double precision);


// Вычисление расстояния между точкой и прямой, заданной двумя точками
// При ошибке параметров возвращает 0

_MAPIMP double _MAPAPI ovlDistance(DOUBLEPOINT* point, DOUBLEPOINT* p1,
                                   DOUBLEPOINT* p2);

// Вычисление квадрата расстояния между точкой и прямой, заданной
// двумя точками (более быстрая функция по сравнению с ovlDistance)
// При ошибке параметров возвращает 0

_MAPIMP double _MAPAPI ovlDistance2(DOUBLEPOINT* point, DOUBLEPOINT* p1,
                                    DOUBLEPOINT* p2);


// Поиск точки на линии, ближайшей к заданной             17/10/12
//   p     - заданная точка
//   p1,p2 - точки отрезка, определяющие линию
//   pRes  - точка на линии (p1,p2), ближайшая к заданной (p)
// При ошибке параметров возвращает 0

_MAPIMP long int _MAPAPI ovlSeekNearPointOnLine(DOUBLEPOINT* p, DOUBLEPOINT* p1,
                                                DOUBLEPOINT* p2, DOUBLEPOINT* pRes);


//******************************************************************
// ФУНКЦИИ ЗАПРОСА ПОЛОЖЕНИЯ ТОЧКИ
//******************************************************************

// Запросить расположение точки относительно замкнутого объекта
// (с учетом подобъектов)
//   point     - координаты точки (в метрах)
//   info      - замктутый площадной или линейный объект
//   precision - точность, используемая для проверки равенства точек.
//               При precision <= 0 устанавливается DOUBLENULL
// Возвращает:
//   1 - точка внутри объекта
//   2 - точка вне объекта
//   3 - точка лежит на контуре объекта
// При ошибке возвращает 0

_MAPIMP long int _MAPAPI ovlGetLocationPoint(DOUBLEPOINT* point, HOBJ info,
                                             double precision);


//******************************************************************
// ФУНКЦИИ ПЕРЕСЕЧЕНИЯ ОБЪЕКТОВ
//******************************************************************

/********************** ПРИМЕР ИСПОЛЬЗОВАНИЯ ***********************

  // Создать пустой объект для записи шаблона для обрезки объектов
  HOBJ templet = mapCreateSiteObject(hmap, hsite, IDDOUBLE2, 0);

  // Создать пустой объект для записи обрабатываемого объекта
  HOBJ object = mapCreateSiteObject(hmap, hsite, IDDOUBLE2, 0);

  // Создать пустой объект для записи результата
  // (для записи результата рекомендуется тип IDDOUBLE2 или IDDOUBLE3)
  HOBJ objectpart = mapCreateSiteObject(hmap, hsite, IDDOUBLE2, 0);

  // Запросить объект карты
  mapReadObjectByNumber(hmap, hsite, templet, 1, templetnumber);

  // Запросить объект карты
  mapReadObjectByNumber(hmap, hsite, object, 1, objectnumber);

  // Установить тип результирующего объекта равным типу обрабатываемого
  mapDescribeObject(objectpart, mapObjectCode(object));

  // Создать объект оверлейных операций
  HOVL hovl = ovlCreate(hmap, 1, DOUBLENULL);

  if (hovl == 0)
  {
    // Ошибка создания объекта оверлейных операций
  }
  else
  {
    // Установить шаблон для оверлейных операций
    // (по основному контуру объекта, с согласованием контура
    //  шаблона с обрабатываемыми объектами)
    int res = ovlSetTemplet(hovl, templet, 0, 1);

    if (res == 0)
    {
      // Запросить код ошибки
      if (ovlGetErrorCode(hovl) != 0)
      {
        // Запросить описание ошибки для вывода в окно или записи в журнал
        ::MessageBox(0, ovlGetError(hovl), "", MB_OK);
      }
    }
    else
    {
      int errorcode = 0;

      // Установить обрабатываемый объект и метод обработки
      // (все контура, результат - все линейные контура)
      int location = ovlSetObjectCross(hovl, object, -1, 0.0, 0, METHOD_LINE, 0);

      // Расположение объекта относительно шаблона
      if (location == 0)
      {
        // Запросить код ошибки
        if (ovlGetErrorCode(hovl) != 0)
        {
          // Запросить описание ошибки
          ::MessageBox(0, ovlGetError(hovl), "", MB_OK);
        }
      }
      else if (location == 1)
      {
        // Объект внутри шаблона
        // ...
      }
      else if (location == 2)
      {
        // Объект вне шаблона
        // ...
      }
      else  // location == 3 или 4 (Объект пересекается с шаблоном)
      {
        int side;

        while(1)
        {
          // Запросить очередную часть разрезаемого объекта
          side = ovlGetNextObject(hovl, objectpart);

          if (side == 0)
          {
            // Запросить код ошибки
            if (ovlGetErrorCode(hovl) != 0)
            {
              // Запросить описание ошибки
              ::MessageBox(0, ovlGetError(hovl), "", MB_OK);
              break;
            }

            // Запросить метрику основного контура шаблона, согласованного
            // с частями разрезаемого объекта
            if (ovlGetAdjustTemplet(hovl, templet, 0))
            {
              // Сохранить объект, если контур шаблона обновился
              mapCommitObject(templet);
            }
            else
            {
              // Запросить код ошибки
              if (ovlGetErrorCode(hovl) != 0)
              {
                // Запросить описание ошибки
                ::MessageBox(0, ovlGetError(hovl), "", MB_OK);
              }
            }

            // Поиск частей разрезаемого объекта закончен
            break;
          }

          // Установить разные коды объектов для результирующих объектов
          if (side == 1)
          {
            // Объект, находящийся внутри шаблона
            mapRegisterObjectByKey(objectpart, "L1000000008");
          }
          else
          {
            // Объект, находящийся вне шаблона
            mapRegisterObjectByKey(objectpart, "L1000000007");
          }

          // Сохранить объект objectpart
          mapCommitObjectAsNew(objectpart);
        }
      }
    }

    // Освободить объект оверлейных операций
    ovlFree(hovl);
  }

  // Освободить объекты
  mapFreeObject(objectpart);
  mapFreeObject(object);
  mapFreeObject(templet);

*******************************************************************/


// Создать объект оверлейных операций
// Объект позволяет:
// 1 Запросить расположение метрики объекта любой локализации
//   относительно шаблона
// 2 Согласовать точки контура объекта с точками контура шаблона
//   перед поиском пересечений (в пределах допуска)
// 3 Запросить метрику шаблона, топологически согласованную
//   с частями разрезаемого объекта
// 4 Запросить все точки пересечения объектов
// 5 Запросить очередную часть разрезаемого объекта:
//   5.1 Рассечение контуров объектов по замкнутому контуру
//   5.2 Рассечение контуров объектов по незамкнутому контуру
//   5.3 Рассечение площадных объектов по замкнутому контуру
//   hmap      - идентификатор открытых данных (используется для
//               запроса высоты при разрезании объекта с 3D-метрикой)
//   flag      - флаг проверки контуров исходных объектов на самопересечение:
//               1 - проверка на самопересечение выполняется (рекомендуется)
//               0 - проверка на самопересечение отключена (используется
//                   для ускорения обработки в задачах визуализации).
//                   При использовании данного флага при обработке объектов,
//                   содержащих ошибки самопересечения, возвращается ошибка
//                   "Ошибка обработки. Отключена проверка на самопересечение"
//   precision - точность, используемая для проверки равенства точек.
//               При precision <= 0 устанавливается DOUBLENULL
//   !!! При сохранении объектов в карту с точностью < precision
//       результирующие контура могут содержать петли (при округлении 
//       координат точек близко расположенные точки могут совпасть) !!!
// Возвращает идентификатор объекта оверлейных операций.
// Для выгрузки из памяти вызывать функцию ovlFree.
// При ошибке возвращает 0

_MAPIMP HOVL _MAPAPI ovlCreate(HMAP hmap, long int flag, double precision);


//------------------------------------------------------------------
// Создать объект оверлейных операций для выполения контроля метрики объекта
// (обрабатываются только линейные или площадные объекты)
//------------------------------------------------------------------
//   object    - обрабатываемый объект
//   flag      - тип контроля
//               1 - контроль самопересечений
//               7 - контроль самопересечений с дополнительными проверками:  // 14/12/11
//                   на близость несоседних точек контура (поиск "затяжек",
//                   "выбросов", "сближений участков" контуров);
//                   на близость соседних точек контура (поиск двойных точек
//                   в допуске precision).
//   precision - точность, используемая для проверки близости точек.
//               При precision <= 0 устанавливается DOUBLENULL
// Возвращает идентификатор объекта оверлейных операций.
// Для выгрузки из памяти вызывать функцию ovlFree.
// При ошибке возвращает 0.
// Для запроса результатов контроля использовать функции:
//   ovlGetErrorCount, ovlGetErrorN, ovlGetErrorPointXN, ovlGetErrorPointYN
//------------------------------------------------------------------
_MAPIMP HOVL _MAPAPI ovlCreateCheckObject(HOBJ object, long int flag,
                                          double precision);

// Освободить объект оверлейных операций
//   hovl - идентификатор объекта оверлейных операций

_MAPIMP void _MAPAPI ovlFree(HOVL hovl);


// Установить шаблон для оверлейных операций
//   hovl     - идентификатор объекта оверлейных операций
//   templet  - шаблон, объект по контуру которого выполняются
//              оверлейные операции
//   subject  - номер контура, используемого в качестве шаблона (лекала)
//                0 - основной контур объекта templet,
//                от 1 и более - подобъект объекта templet
//   adjust   - флаг согласования метрики контура шаблона с пересекаемыми
//              объектами (0,1). Выполняется вставка точек пересечений в контур
// При ошибке возвращает 0
// Для запроса описания ошибок вызывать функции ovlGetErrorCount и ovlGetErrorN

_MAPIMP long int _MAPAPI ovlSetTemplet(HOVL hovl, HOBJ templet, long int subject,
                                       long int adjust);


// Установить обрабатываемый объект и метод обработки
//   hovl     - идентификатор объекта оверлейных операций
//   object   - обрабатываемый объект
//   subject  - номер обрабатываемого контура:
//               -1 - обработать все контура
//                0 - основной контур объекта,
//                от 1 и более - подобъект объекта
//  precision - точность согласования точек объекта с точками шаблона
//              (DOUBLENULL и выше). Выполняется обновление точек объекта.
//              Используется для сохранения контуров близлежащих объектов.
//              Рекомендуется precision = 0.001 (метров на местности)
//   flag3d   - флаг формирования высоты в точках трехмерной метрики,
//              соответствующих участкам контуров шаблона:
//                FLAG3D_NONE    (0) - результат не содержит трехмерной метрики
//                FLAG3D_TEMPLET (2) - третья координата выбирается из контура
//                                     шаблона
//                FLAG3D_MATRIX  (8) - третья координата выбирается из карты
//                                     (по наиболее точной открытой матрице высот)
//                FLAG3D_LINE   (32) - третья координата вычисляется по крайним
//                                     точкам участка, не содержащего высоты
//                                     (методом линейной интерполяции)
//                FLAG3D_ALL    (42) - совместное использование всех флагов
//                                     FLAG3D_TEMPLET|FLAG3D_MATRIX|FLAG3D_LINE
//              Допускается совместное использование флагов:
//                FLAG3D_TEMPLET|FLAG3D_MATRIX, FLAG3D_MATRIX|FLAG3D_LINE,
//                FLAG3D_TEMPLET|FLAG3D_LINE
//              При совместном использовании используется приоритет выполнения:
//                FLAG3D_TEMPLET -> FLAG3D_MATRIX -> FLAG3D_LINE
//              Если исходный объект не содержит трехмерную метрику,
//              то допустим только метод 0
//   method   - флаг типа результирующих контуров (флаги метода обработки):
//                METHOD_LINE   0 - замкнутые и незамкнутые контура линейных объектов
//                METHOD_SQUARE 1 - замкнутые контура (части object) площадных объектов
//                METHOD_FAST  16 - быстрый способ обработки - используется только
//                                  для объектов, которые не содержат самопересечений !!!
//              Если контур шаблона незамкнут, то допустим только метод METHOD_LINE.
//              Допускается совместное использование флагов:
//                METHOD_LINE|METHOD_FAST, METHOD_SQUARE|METHOD_FAST
//   location - флаги размещения результирующих контуров:
//                ANYOBJECT или 0 - поиск всех контуров
//                ANYOBJECT2      - поиск всех контуров, включая отрезки
//                                  контура равные отрезкам шаблона
//                OBJECTINSIDE    - поиск контуров внутри шаблона
//                OBJECTINSIDE2   - поиск контуров внутри шаблона, включая
//                                  отрезки контура равные отрезкам шаблона
//                OBJECTOUTSIDE   - поиск контуров вне шаблона
//                OBJECTOUTSIDE2  - поиск контуров вне шаблона, включая
//                                  отрезки контура равные отрезкам шаблона
//                OBJECTOVERLAP   - поиск совпадающих участков контуров  // 15/07/13
//              Допускается совместное использование флагов:
//                OBJECTINSIDE|OBJECTOUTSIDE, OBJECTINSIDE2|OBJECTOUTSIDE,
//                OBJECTINSIDE|OBJECTOUTSIDE2, OBJECTINSIDE2|OBJECTOUTSIDE2
// Если объект точечный, векторный, подпись или шаблон, то параметры
// precision,method,location игнорируются. Положение объекта определяется
// по первой точке первого подобъекта, а функция ovlSetObjectCross возвращает:
//   1 - объект внутри шаблона                          // 15/06/10
//   2 - объект вне шаблона
//       (ovlGetNextObject не вызывать !!!)
// Если контур шаблона НЕЗАМКНУТ, то ovlSetObjectCross возвращает:
//   1 - все контура объекта совпадают с шаблоном (лежат на шаблоне)
//   2 - все контура объекта вне шаблона
//   3 - один или несколько контуров объекта пересекаются с шаблоном
//       (при возврате 3 вызывать ovlGetNextObject в цикле !!!)
// Если контур шаблона ЗАМКНУТ и method == 0, то ovlSetObjectCross возвращает:
//   1 - все контура объекта внутри шаблона, либо совпадают
//   2 - все контура объекта вне шаблона
//   3 - один или несколько контуров объекта пересекаются с шаблоном,
//       либо обнаружены внутренние и внешние контура (относительно шаблона)
// Если контур шаблона ЗАМКНУТ и method == 1, то ovlSetObjectCross возвращает:
//   1 - все контура объекта внутри шаблона, либо совпадают
//   2 - все контура объекта вне шаблона
//   3 - один или несколько контуров объекта пересекаются с шаблоном,
//       либо обнаружены внутренние и внешние контура (относительно шаблона)
//   4 - контур шаблона внутри контура объекта
//       (при возврате 3 и 4 вызывать ovlGetNextObject в цикле !!!)
// При ошибке возвращает 0
// Для запроса кода ошибки вызывать функции GetErrorCode и GetError

_MAPIMP long int _MAPAPI ovlSetObjectCross(HOVL hovl, HOBJ object, long int subject,
                                           double precision, long int flag3d,
                                           long int method, long int location);


// Запросить очередную часть разрезаемого объекта
// (вызывать после ovlSetObjectCross в цикле до тех пор, пока не вернет 0)
//   hovl   - идентификатор объекта оверлейных операций
//   object - объект для возврата результата. !!! Для получения
//            наилучших результатов тип метрики объекта должен быть
//            равен IDDOUBLE2 или IDDOUBLE3 !!! (см. mapSetObjectKind)
// Если контур шаблона ЗАМКНУТ, то ovlGetNextObject возвращает:
//   1 - контур объекта внутри шаблона (часть контура может совпадать
//       с контуром шаблона), либо совпадает с контуром шаблона
//   2 - контур объекта вне шаблона (часть контура может совпадать
//       с контуром шаблона)
//   0 - контуров больше нет, либо при ошибке
// Если контур шаблона НЕЗАМКНУТ, то ovlGetNextObject возвращает:
//   1 - контур объекта совпадает с контуром шаблона (лежит на шаблоне)
//   2 - контур объекта вне шаблона (контур может касаться шаблона
//       одной или двумя точками)
//   0 - контуров больше нет, либо при ошибке
// Если в функции ovlSetObjectCross установлено location = OBJECTOVERLAP,
// то ovlGetNextObject возвращает:
//   1 - контур совпадает (Поиск совпадающих участков контуров) // 15/07/13
//   2 - контур не совпадает
//   0 - контуров больше нет, либо при ошибке
// При возврате 0 необходимо проверить код ошибки.
// Для запроса описания ошибок вызывать функции ovlGetErrorCount и ovlGetErrorN

_MAPIMP long int _MAPAPI ovlGetNextObject(HOVL hovl, HOBJ object);


// Запросить признак изменения метрики шаблона, согласованного с метрикой
// объекта (при вызове функции ovlSetObjectCross в метрику шаблона
// вставляются точки пересечения контуров шаблона и объекта)
// Возвращает: 1 - метрика изменена, 0 - метрика не изменена

_MAPIMP long int _MAPAPI ovlIsEditTemplet(HOVL hovl);    // 12/08/11


// Запросить признак изменения метрики объекта, согласованного с метрикой
// шаблона (при вызове функции ovlSetObjectCross в метрику объекта
// вставляются точки пересечения контуров шаблона и объекта)
// Возвращает: 1 - метрика изменена, 0 - метрика не изменена

_MAPIMP long int _MAPAPI ovlIsEditObject(HOVL hovl);     // 12/08/11


// Запросить метрику шаблона, согласованную с метрикой объекта
// (при вызове функции ovlSetObjectCross в метрику шаблона
//  вставляются точки пересечения контуров шаблона и объекта)
//   hovl    - идентификатор объекта оверлейных операций
//   templet - объект для возврата результата
//   subject - номер сохраняемого подобъекта
//                   0 или больше - записать только один контур шаблона
//                  -1 - записать все контура шаблона
// При ошибке возвращает 0
// Для запроса кода ошибки вызывать функции ovlGetErrorCode и ovlGetError

_MAPIMP long int _MAPAPI ovlGetAdjustTemplet(HOVL hovl, HOBJ templet,
                                             long int subject);


// Запросить метрику объекта, согласованную с метрикой шаблона
// (при вызове функции ovlSetObjectCross в метрику объекта
//  вставляются точки пересечения контуров шаблона и объекта)
//   hovl    - идентификатор объекта оверлейных операций
//   object  - объект для возврата результата
//   subject - номер сохраняемого подобъекта
//                   0 или больше - записать только один контур объекта
//                  -1 - записать все контура объекта
// При ошибке возвращает 0
// Для запроса кода ошибки вызывать функции ovlGetErrorCode и ovlGetError

_MAPIMP long int _MAPAPI ovlGetAdjustObject(HOVL hovl, HOBJ object,
                                            long int subject);  // 27/07/11


// Запросить метрику проверенного объекта (с удалением двойных точек,
// обнаруженных в функции ovlCreateCheckObject). Вызывать только при
// выполнении контроля (ovlCreateCheckObject)
//   obj          - объект для записи результата
//   subject      - номер сохраняемого подобъекта
//                   0 или больше - записать только основной контур объекта
//                  -1 - записать все контура объекта
// При ошибке возвращает 0

_MAPIMP long int _MAPAPI ovlGetCheckObject(HOVL hovl, HOBJ object,
                                           long int subject);  // 04/04/12


// Запросить все точки пересечения объектов (точки пересечения
// записываются в объект). Точки пересечения каждого контура
// обрабатываемого объекта записываются в отдельные контура
//   hovl   - идентификатор объекта оверлейных операций
//   points - объект для возврата результата
// При ошибке возвращает 0
// Для запроса кода ошибки вызывать функции ovlGetErrorCode и ovlGetError

_MAPIMP long int _MAPAPI ovlGetCrossPoints(HOVL hovl, HOBJ points);


// Запросить код ошибки
//   hovl - идентификатор объекта оверлейных операций
// Возвращает код ошибки (OVL_ERR_NONE, ...)

_MAPIMP long int _MAPAPI ovlGetErrorCode(HOVL hovl);


// Запросить описание ошибки (ошибка обнуляется для дальнейшего
// использования объекта оверлейных операций)
//   hovl - идентификатор объекта оверлейных операций
// Возвращает описание ошибки

_MAPIMP const char * _MAPAPI ovlGetError(HOVL hovl);
_MAPIMP const WCHAR * _MAPAPI ovlGetErrorUn(HOVL hovl);

// Запросить число ошибок
//   hovl - идентификатор объекта оверлейных операций
// Возвращает число ошибок

_MAPIMP long int _MAPAPI ovlGetErrorCount(HOVL hovl);   // 15/09/11


// Запросить код ошибки
//   hovl   - идентификатор объекта оверлейных операций
//   number - порядковый номер ошибки (от 1 до ovlGetErrorCount)
// Возвращает код ошибки (OVL_ERR_NONE, ...)

_MAPIMP long int _MAPAPI ovlGetErrorCodeN(HOVL hovl, long int number);


// Запросить описание ошибки (ошибка обнуляется для дальнейшего
// использования объекта оверлейных операций)
//   hovl   - идентификатор объекта оверлейных операций
//   number - порядковый номер ошибки (от 1 до ovlGetErrorCount)
// Возвращает описание ошибки на русском языке

_MAPIMP const char* _MAPAPI ovlGetErrorN(HOVL hovl, long int number);


// Запросить координаты точки, содержащей ошибку
//   hovl - идентификатор объекта оверлейных операций
// При обнаружении самопересечения контура возвращает точку, содержащую ошибку.
// При обнаружении ошибки при обработке шаблона возвращает первую точку шаблона.
// В остальных случаях возвращает первую точку обрабатываемого объекта
// При ошибке возвращает 0.0

_MAPIMP double _MAPAPI ovlGetErrorPointX(HOVL hovl);
_MAPIMP double _MAPAPI ovlGetErrorPointY(HOVL hovl);


// Запросить координаты точки, содержащей ошибку
//   hovl - идентификатор объекта оверлейных операций
//   number - порядковый номер ошибки (от 1 до ovlGetErrorCount)
// При обнаружении самопересечения контура возвращает точку, содержащую ошибку.
// При обнаружении ошибки при обработке шаблона возвращает первую точку шаблона.
// В остальных случаях возвращает первую точку обрабатываемого объекта
// При ошибке возвращает 0.0

_MAPIMP double _MAPAPI ovlGetErrorPointXN(HOVL hovl, long int number);
_MAPIMP double _MAPAPI ovlGetErrorPointYN(HOVL hovl, long int number);

} // extern "C"

#endif // CROSSAPI_H

