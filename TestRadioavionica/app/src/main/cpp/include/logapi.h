/****** LOGAPI.H *************** Vitsko      O.V. ***** 23/11/05 ***
******* LOGAPI.H *************** Belenkov    O.V. ***** 23/12/14 ***
*                                                                  *
*              Copyright (c) PANORAMA Group 1991-2014              *
*                      All Rights Reserved                         *
*                                                                  *
********************************************************************
*                                                                  *
*       ОПИСАНИЕ КЛАССА ДОСТУПА К ОБ'ЕКТУ "ЖУРНАЛ ТРАНЗАКЦИЙ"      *
*        ИНТЕРФЕЙС ДЛЯ ПРОГРАММ НА ЯЗЫКАХ C, PASCAL, BASIC         *
*                                                                  *
*******************************************************************/

#ifndef LOGAPI_H
#define LOGAPI_H

#ifndef MAPTYPE_H
  #include "maptype.h"
#endif


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++ ОПИСАНИЕ ФУНКЦИЙ ДОСТУПА К ЖУРНАЛУ ТРАНЗАКЦИЙ +++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++

extern "C"
{

 // Запросить - ведется ли журнал транзакций
 // hMap  - идентификатор открытой карты
 // hSite - идентификатор открытой пользовательской карты
 // 0 - не ведется, иначе - ведется
 
_MAPIMP long int _MAPAPI mapGetLogAccess(HMAP hMap, HSITE hSite);


 // Запретить/Разрешить ведение журнала транзакций (0/1)
 // После открытия карты ведение журнала разрешено.
 // Допускается использовать только при потоковой обработке
 // объектов, когда быстродействие важнее возможности
 // сохранить данные при сбое системы !
 // Перед отключением журнала рекомендуется позаботиться о
 // резервной копии данных !
 // hMap  - идентификатор открытой карты
 // hSite - идентификатор открытой пользовательской карты 
 // При ошибке возвращает ноль

_MAPIMP long int _MAPAPI mapLogAccess(HMAP hMap, HSITE hSite,long int mode);


 // Запросить число транзакций в журнале
 // hMap  - идентификатор открытой карты
 // hSite - идентификатор открытой пользовательской карты
 // При ошибке возвращает ноль

_MAPIMP long int _MAPAPI mapLogCount(HMAP hMap, HSITE hSite);


 // Запросить дату создания журнала
 // hMap  - идентификатор открытой карты
 // hSite - идентификатор открытой пользовательской карты
 // date - дата в формате "YYYYMMDD"
 // time - время в формате "число секунд от 00:00:00"
 // на указанную дату
 // При ошибке возвращает ноль

_MAPIMP long int _MAPAPI mapLogDate(HMAP hMap, HSITE hSite,
                                    long int * date, long int * time);


 // Открыть запись транзакции
 // hMap  - идентификатор открытой карты
 // hSite - идентификатор открытой пользовательской карты
 // type - тип транзакции (от 0x4000 до 0х0FFFF - за Панорамой)
 // При ошибке возвращает ноль

_MAPIMP long int _MAPAPI mapLogCreateAction(HMAP hMap, HSITE hSite,
                                            long int type);


 // Внести в описание транзакции сведения об операции
 // hMap  - идентификатор открытой карты
 // hSite - идентификатор открытой пользовательской карты
 // Структура ACTIONRECORD описана в maptype.h
 // При ошибке возвращает ноль

_MAPIMP long int _MAPAPI mapLogPutRecord(HMAP hMap, HSITE hSite,
                                         ACTIONRECORD * record);


 // Закрыть запись транзакции
 // hMap  - идентификатор открытой карты
 // hSite - идентификатор открытой пользовательской карты
 // Возвращает число выполненных операций в транзакции для карты   // 23/12/14
 // Если число транзакций не может быть определено возвращает -1   
 // При ошибке возвращает ноль

_MAPIMP long int _MAPAPI mapLogCommitAction(HMAP hMap, HSITE hSite);


 // Запросить номер первой транзакции,выполненной
 // после указанных даты и времени
 // hMap  - идентификатор открытой карты
 // hSite - идентификатор открытой пользовательской карты
 // date - дата в формате "YYYYMMDD"
 // time - время в формате "число секунд от 00:00:00"
 // на указанную дату (по Гринвичу - GetSystemTime, in Coordinated Universal Time (UTC))
 // При ошибке возвращает ноль

_MAPIMP long int _MAPAPI mapLogGetActionNumberByTime(HMAP hMap, HSITE hSite,
                                                     long int date,
                                                     long int time);


 // Считать заголовок описания последней не отмененной транзакции
 // задачи из журнала
 // Если после транзакции выполнялась сортировка карты
 // или журнал пуст - возвращает ноль
 // hMap  - идентификатор открытой карты
 // hSite - идентификатор открытой пользовательской карты
 // Структура ACTIONRECORD описана в maptype.h
 // При ошибке возвращает ноль,
 // иначе - номер транзакции

_MAPIMP long int _MAPAPI mapReadLastAction(HMAP hMap, HSITE hSite,
                                           ACTIONHEAD * head);


 // Считать заголовок описания последней не отмененной транзакции
 // задачи из журнала
 // flag - условия выбора последней транзакции:
 // LOG_ANYACTION(0) - нет условий, LOG_MYACTION(1) - считывать последнюю
 // свою транзакцию (пропускать транзакции других пользователей)
 // Если после транзакции выполнялась сортировка карты
 // или журнал пуст - возвращает ноль
 // hMap  - идентификатор открытой карты
 // hSite - идентификатор открытой пользовательской карты
 // Структура ACTIONRECORD описана в maptype.h
 // При ошибке возвращает ноль,
 // иначе - номер транзакции

_MAPIMP long int _MAPAPI mapReadLastActionEx(HMAP hMap, HSITE hSite,
                                             ACTIONHEAD * head, long int flag);

 // Считать заголовок описания последней транзакции "Шаг назад" и
 // запросить номер отмененной транзакции (подготовка команды "Восстановить")
 // hMap  - идентификатор открытой карты
 // hSite - идентификатор открытой пользовательской карты
 // head  - адрес поля для записи заголовка транзакции "Шаг назад"
 // Структура ACTIONRECORD описана в maptype.h
 // actionnumber - адрес поля для записи номера отмененной транзакции,
 // flag         - условия выбора последней транзакции "Шаг назад":
 // LOG_ANYACTION(0) - нет условий, LOG_MYACTION(1) - считывать последнюю
 // свою транзакцию (пропускать транзакции других пользователей)
 // Если после транзакции выполнялась сортировка карты
 // или журнал пуст - возвращает ноль
 // При ошибке возвращает ноль, иначе - номер транзакции

_MAPIMP long int _MAPAPI mapReadLastUndoActionEx(HMAP hMap, HSITE hSite,
                                                 ACTIONHEAD * head, 
                                                 long int * actionnumber, 
                                                 long int flag);

 // Считать заголовок описания транзакции из журнала
 // number - последовательный номер транзакции
 // (от 1 до Count(...)).
 // hMap  - идентификатор открытой карты
 // hSite - идентификатор открытой пользовательской карты
 // Структура ACTIONRECORD описана в maptype.h
 // При ошибке возвращает ноль,
 // иначе - число операций в транзакции
_MAPIMP long int _MAPAPI mapLogReadAction(HMAP hMap, HSITE hSite,
                                          long int number, ACTIONHEAD * head);

 // Запросить сведения об операции
 // number - последовательный номер транзакции (от 1)
 // recnumber - номер операции (от 1 до ReadAction(...))
 // hMap  - идентификатор открытой карты
 // hSite - идентификатор открытой пользовательской карты
 // Структура ACTIONRECORD описана в maptype.h
 // При ошибке возвращает ноль

_MAPIMP long int _MAPAPI mapLogGetActionRecordEx(HMAP hMap, HSITE hSite,
                                                 long int number,
                                                 long int recnumber,
                                                 ACTIONRECORD * record);

_MAPIMP long int _MAPAPI mapLogGetActionRecord(HMAP hMap, HSITE hSite,
                                               long int recnumber,
                                               ACTIONRECORD * record);

 // Запросить количество операций в транзакции
 // hMap   - идентификатор открытой карты
 // hSite  - идентификатор открытой пользовательской карты
 // number - номер транзакции
 // При ошибке возвращает ноль

_MAPIMP long int _MAPAPI mapLogGetActionRecordCountEx(HMAP hMap, HSITE hSite,
                                                      long int number);

_MAPIMP long int _MAPAPI mapLogGetActionRecordCount(HMAP hMap, HSITE hSite);

 // Запросить доступен ли журнал на запись
 // hMap  - идентификатор открытой карты
 // hSite - идентификатор открытой пользовательской карты
 // При ошибке возвращает ноль

_MAPIMP long int _MAPAPI mapLogIsWrite(HMAP hMap, HSITE hSite);


 // Отменить последнюю транзакцию
 // hMap  - идентификатор открытой карты
 // hSite - идентификатор открытой пользовательской карты
 // Если после транзакции выполнялась сортировка карты
 // или журнал пуст - возвращает ноль
 // При ошибке возвращает ноль,
 // иначе - количество восстановленных операций

_MAPIMP long int _MAPAPI mapLogAbolitionLastAction(HMAP hMap, HSITE hSite);

 // Восстановить последнюю отмененную транзакцию  // 05/07/10
 // flag - условия выбора последней транзакции:
 // LOG_ANYACTION(0) - нет условий, LOG_MYACTION(1) - считывать последнюю
 // свою транзакцию (пропускать транзакции других пользователей)
 // Если после отмены транзакции выполнялись другие операции или
 // выполнялась сортировка карты или журнал пуст - возвращает ноль
 // При ошибке возвращает ноль,
 // иначе - количество восстановленных операций

_MAPIMP long int _MAPAPI mapLogRedoLastAction(HMAP hMap, HSITE hSite,
                                              long int flag);

 // Отменить последнюю транзакцию
 // hMap  - идентификатор открытой карты
 // hSite - идентификатор открытой пользовательской карты
 // flag - условия выбора последней транзакции:
 // LOG_ANYACTION(0) - нет условий, LOG_MYACTION(1) - обрабатывать последнюю
 // свою транзакцию (пропускать транзакции других пользователей)
 // Если после транзакции выполнялась сортировка карты
 // или журнал пуст - возвращает ноль
 // При ошибке возвращает ноль,
 // иначе - количество восстановленных операций

_MAPIMP long int _MAPAPI mapLogAbolitionLastActionEx(HMAP hMap, HSITE hSite,
                                                     long int flag);


 // Отменить последнюю транзакцию в документе                 // 26/07/11
 // Если после транзакции выполнялась сортировка карты
 // или журнал пуст - возвращает ноль
 // hMap  - идентификатор открытой карты
 // hSite - поле для записи идентификатора карты, на которой выполнена
 //         отмена транзакции
 // flag - условия выбора последней транзакции:
 // LOG_ANYACTION(0) - нет условий, LOG_MYACTION(1) - обрабатывать последнюю
 // свою транзакцию (пропускать транзакции других пользователей)
 // При ошибке возвращает ноль,
 // иначе - количество восстановленных операций

_MAPIMP long int _MAPAPI mapLogUndoAction(HMAP hMap, HSITE * hSite, long int flag);


 // Прочитать последнюю транзакцию в документе,которую можно отменить    // 31/07/11
 // Если после транзакции выполнялась сортировка карты
 // или журнал пуст - возвращает ноль
 // hMap  - идентификатор открытой карты
 // hSite  - поле для записи идентификатора карты, на которой выполнена
 //          отмена транзакции
 // flag - условия выбора последней транзакции:
 // LOG_ANYACTION(0) - нет условий, LOG_MYACTION(1) - обрабатывать последнюю
 // свою транзакцию (пропускать транзакции других пользователей)
 // При ошибке возвращает ноль, иначе - номер транзакции

_MAPIMP long int _MAPAPI mapLogReadActionForUndo(HMAP hMap, HSITE * hSite, long int flag);

 // Сохранить журнал транзакций (и переоткрыть файл)
 // hMap  - идентификатор открытой карты
 // hSite - идентификатор открытой пользовательской карты

_MAPIMP void _MAPAPI mapLogFlush(HMAP hMap, HSITE hSite);


 // Запросить идентификатор текущего компьютера
 // Записывается в поле Task структуры ACTIONHEAD
 // hMap  - идентификатор открытой карты
 // hSite - идентификатор открытой пользовательской карты
 // При ошибке возвращает ноль

_MAPIMP long int _MAPAPI mapLogGetMyIdent(HMAP hMap, HSITE hSite);

 // Запросить имя текущего компьютера и пользователя  
 // Записывается в поле Task структуры ACTIONHEAD
 // При ошибке возвращает ноль

_MAPIMP const char * _MAPAPI mapLogGetMyName(HMAP hMap, HSITE hSite);
_MAPIMP const WCHAR * _MAPAPI mapLogGetMyNameUn(HMAP hMap, HSITE hSite);

 // Установить монопольный доступ ко всем открываемым векторным картам
 // Ускоряет все операции редактирования карт за счет буферизации
 // операций записи на диск при значении access не равном 0
 // При монопольном доступе другие приложения не смогут
 // редактировать карту
 // Если какая-либо карта не может быть открыта в монопольном
 // доступе - признак автоматически сбрасывается
 // Возвращает новое значение признака монопольного доступа

_MAPIMP long int _MAPAPI mapSetExclusiveAccess(long int access);

 // Запросить значение признака монопольного доступа к открываемым векторным картам

_MAPIMP long int _MAPAPI mapGetExclusiveAccess(void);

}  // extern "C"

#endif